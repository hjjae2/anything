## 대규모 데이터를 다루는 세 가지 요령

**1. 최대한 메모리에서 처리한다.**
   - ex: disk seek 횟수 최소화
   - ex: 국소성 활용한 분산 실현

**2. (데이터량에 따른) 효율적인 알고리즘/자료구조 사용**
   - ex: 선형 탐색 -> 이분 탐색

**3. 데이터 압축, 검색 기술과 같은 테크닉**
   - ex: 데이터 압축(데이터 용량 ↓) = 메모리 처리 ↑ = seek 횟수 ↓

<br><br>

### Load Average 다음은 CPU 사용률, I/O 대기율

과부하로 시스템의 성능이 떨어지는 원인은 대부분의 경우에 CPU, I/O에 있다.

Load Average 를 보고 대응이 필요하다고 판단한 경우, 다음 단계로 CPU, I/O 중 어느 쪽에 원인이 있는지를 조사해야 한다.

> p.51 에 sar 명령어를 통해 cpu %, iowait % 를 확인하고, 설명하고 있다.

|경우|설명|
|-|-|
|Load Average 높음 & CPU 사용량 높음|부하 원인이 CPU(리소스 부족) 라고 판단할 수 있다. (100% 확정할 수는 없다.)|
|Load Average 높음 & I/O 대기율 높음|부하 원인이 I/O 라고 판단할 수 있다. (100% 확정할 수는 없다.)|

> *" 멀티 코어 CPU, Disk 하나 인 경우 CPU 부하는 분산돼도 I/O 부하는 분산되지 않는다. 코어 별로 (I/O wait)지표 값을 확인해보면 확실하게 알 수 있다. 따라서 멀티 코어 환경에서는 지표 값을 코어 별로(개별적으로) 확인할 필요도 있다. "*