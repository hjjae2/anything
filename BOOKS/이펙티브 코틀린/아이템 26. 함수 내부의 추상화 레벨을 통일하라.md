> *" **컴퓨터 과학에서 추상화는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다.** <br> ... 조금 간단하게 표현하면, 추상화는 복잡성을 숨기기 위해 사용되는 방식을 의미한다. "*

인터페이스는 클래스라는 복잡한 것에서 메서드, 프로퍼티만 추출해서 간단하게 만들었으므로 클래스의 추상화라고 볼 수 있다.

추상화를 하려면 무엇을 감추고 무엇을 노출해야 하는지 결정해야 한다. (잘 결정하지 못하면 추상화 능력이 떨어진다고 볼 수 있다.)

<br>

**일반적으로 프로그래밍에서는 다음과 같은 목적으로 추상화를 사용한다.**

1. 복잡성을 숨기기 위해
2. 코드를 체계화 하기 위해 
3. 만드는 사람에게 변화의 자유를 주기 위해 <br> = 쉽게 확장할 수 있고, 수정할 수 있도록 하기 위해

<br>

## 함수 내부의 추상화 레벨을 통일하라

계층이 잘 분리되면 좋은 점은 다음과 같다.

- 어떤 계층에서 작업할 때, 그 아래 계층은 (완제품을 사용하는 것 처럼)살펴볼 필요 없다. 즉, 해당 계층에 대해서만 작업/생각하면 된다.

<br>

### 추상화 레벨

```
     애플리케이션               <-- 높은 레벨 : 단순함↑ 제어력↓
        |
    프로그래밍언어
        |
      어셈블러
        |
      하드웨어
        |
      물리장치                  <-- 낮은 레벨 : 단순함↓ 제어력↑
```

<br>

### 추상화 레벨 통일

(위의) 컴퓨터 과학과 마찬가지로 코드도 추상화를 통해 계층처럼 만들어 사용할 수 있을 것이다. 이를 위한 기본적인 도구가 **함수**다.

함수도 높은 레벨, 낮은 레벨을 구분해서 사용해야 한다는 원칙이 바로 **추상화 레벨 통일 원칙(Single Level of Abstraction, SLA)** 이다.

```kotlin
fun makeCoffee() {  // 높은 레벨의 함수
    boilWater()     // 낮은 레벨의 함수
    brewCoffee()
    pourCoffee()
    pourMilk()
}
```

위의 예시는 추상화를 통해 가독성을 크게 향상시켰다고 볼 수 있다.

위의 예시처럼 함수는 간단해야 한다. 어떤 함수가 크다면, 일부분을 추출해 별도의 함수로 추상화하는 것이 좋다.

> *" 함수는 작아야 하며, 최소한의 책임만을 가져야 한다. "*

<br>

### 프로그램 아키텍처의 추상 레벨

(아키텍처 관점에서) 추상화를 구분하는 이유는 서브시스템의 세부 사항을 숨김으로써 상호 운영성과 플랫폼 독립성을 얻기 위함이다.

이는 문제 중심으로 프로그래밍한다는 이야기와 같다. :thinking:

```
    높은 레벨의 문제 중심
            |
    낮은 레벨의 문제 중심
            |
    낮은 레벨 구현 구조
            |
    프로그래밍 언어 구조와 도구
            |
    운영 체제 연산과 머신 명령
```

이러한 개념은 모듈 시스템을 설계할 때도 아주 중요하다. **모듈을 분리하면 계층 고유의 요소를 숨길 수 있다.**

예를 들어, 애플리케이션을 만들 때 입/출력을 나타내는 모듈은 '낮은 레벨의 모듈'이다.<br>
반대로 비즈니스 로직을 나타내는 모듈은 '높은 레벨의 모듈'이다.

계층이 잘 분리된 프로젝트를 계층화가 잘 되었다고 말할 수 있다.

<br>

### 요약

- 함수, 클래스, 모듈, 문제 해결 등 다양한 관점에서, 다양한 방식으로 추상화를 분리할 수 있다.
- 각각의 레이어(레벨)이 너무 커지지 않도록 주의해야 한다.
  - 작고 최소한의 책임만 갖는 것이 좋다.
- ('함수' 분리도 추상화 행위라고 볼 수 있었던 것이다. :thinking:)